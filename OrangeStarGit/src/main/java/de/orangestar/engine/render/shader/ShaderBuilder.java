package de.orangestar.engine.render.shader;

/**
 * Provides a fluent shader builder to easily create and compile shader programs as needed.
 * 
 * @author Basti
 */
public class ShaderBuilder {
    
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    /*                              Public                                */
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    
    /**
     * Creates, compiles and returns the setup shader.
     */
    public Shader build() {
        
        StringBuilder strVertex = new StringBuilder();
        xs_head(strVertex);
        vs_in(strVertex);
        vs_out(strVertex);
        vs_main(strVertex);
        
        StringBuilder strFragment = new StringBuilder();
        xs_head(strFragment);
        fs_in(strFragment);
        fs_out(strFragment);
        fs_main(strFragment);
        
        Shader shader = new Shader(strVertex.toString() , strFragment.toString());

        shader._isColored   = _hasColor;
        shader._isTextured  = _hasTexCoord;
        shader._isInstanced = _hasInstanced;
        shader._numInstances= _numInstances;
        
        return shader;
    }

    /**
     * The shader shall support colored rendering.
     */
    public ShaderBuilder colored() {
        _hasColor = true;
        return this;
    }

    /**
     * The shader shall support textured rendering.
     */
    public ShaderBuilder textured() {
        _hasTexCoord = true;
        return this;
    }
    
//    /**
//     * The shader shall support instanced rendering with a maximum of <i>maxInstances</i> instances.
//     */
//    public ShaderBuilder instanced(int maxInstances) {
//        _hasInstanced = true;
//        _numInstances = maxInstances;
//        return this;
//    }
    
    /**
     * The shader shall use a custom vertexshader code.
     * For the shader variable/method naming conventions see {@link Shader}
     */
    public ShaderBuilder withCustomVertexShaderCode(String... srcs) {
        _vertexCustomCode = srcs;
        return this;
    }
    
    /**
     * The shader shall use a custom fragmentshader code.
     * For the shader variable/method naming conventions see {@link Shader}
     */
    public ShaderBuilder withCustomFragmentShaderCode(String... srcs) {
        _fragmentCustomCode = srcs;
        return this;
    }

    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    /*                              Private                               */
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    /**
     * Adds the cross-shader header for setting version, head comments, etc.
     */
    private void xs_head(StringBuilder builder) {
        builder.append("// Generated by ShaderBuilder rev01\n");
        builder.append("#version 330\n");
        builder.append("\n");
    }
    
    /**
     * Adds the IN section to the vertex shader code.
     */
    private void vs_in(StringBuilder builder) {   
        // Uniform
        builder.append("uniform mat4 " + Shader.UniAttribNameWVP + ";");
        
        builder.append("\n\n");
        
        // Layout
        builder.append("layout(location = " + Shader.VsAttribLocPosition + ") in vec3 " + Shader.VsAttribNamePosition + ";\n");
        
        if (_hasColor) {
            builder.append("layout(location = " + Shader.VsAttribLocColor + ") in vec4 " + Shader.VsAttribNameColor + ";\n");
        }
        
        if (_hasTexCoord) {
            builder.append("layout(location = " + Shader.VsAttribLocTexCoord + ") in vec2 " + Shader.VsAttribNameTexCoord + ";\n");
        }
        
        if (_hasInstanced) {
            builder.append("layout(location = " + Shader.VsAttribLocInstances_Position_0 + ") in mat4 " + Shader.VsAttribNameInstances_Position + ";\n");
        }

        builder.append("\n");
    }
    
    /**
     * Adds the OUT section to the vertex shader code.
     */
    private void vs_out(StringBuilder builder) {
        if (_hasColor) {
            builder.append("out vec4 fs_color;" + "\n");
        }
        
        if (_hasTexCoord) {
            builder.append("out vec2 " + Shader.FsAttribNameTexCoord + ";\n");
        }
            
        builder.append("\n");
    }
    
    /**
     * Adds the MAIN method to the vertex shader code.
     */
    private void vs_main(StringBuilder builder) {        
        builder.append("void main() {\n");
        
        
        if (_vertexCustomCode != null) {
            builder.append(_vertexCustomCode);
        } else {
            if (_hasInstanced) {
                builder.append("    gl_Position = (" + Shader.VsAttribNameInstances_Position + " * vec4(vs_position, 1.0)) * uni_wvp;\n");
            } else {
                builder.append("    gl_Position = vec4(vs_position, 1.0) * uni_wvp;\n");
            }

            if (_hasColor) {
                builder.append("    fs_color = vs_color;\n");
            }
            
            if (_hasTexCoord) {
                builder.append("    " + Shader.FsAttribNameTexCoord + " = " + Shader.VsAttribNameTexCoord + ";\n");
            }
        }

        builder.append("}\n");
    }
        
    /**
     * Adds the IN section to the fragment shader code.
     */
    private void fs_in(StringBuilder builder) {
        // Uniform
        if (_hasTexCoord) {
            builder.append("uniform sampler2D " + Shader.UniAttribNameTexture0 + ";\n\n");
        }
        
        // Layout
        if (_hasColor) {
            builder.append("in vec4 " + Shader.FsAttribNameColor + ";\n");
        }
        
        if (_hasTexCoord) {
            builder.append("in vec2 " + Shader.FsAttribNameTexCoord + ";\n");
        }
        
        builder.append("\n");
    }
    
    /**
     * Adds the OUT section to the vertex shader code.
     */
    private void fs_out(StringBuilder builder) {
        builder.append("out vec4 " + Shader.OutAttibNameColor + ";\n");

        builder.append("\n");
    }
    
    /**
     * Adds the MAIN method to the fragment shader code.
     */
    private void fs_main(StringBuilder builder) {

        builder.append("void main() {" + "\n");

        if (_fragmentCustomCode != null) {
            builder.append(_fragmentCustomCode);
        } else {
            if (_hasTexCoord) {
                builder.append("    " + Shader.OutAttibNameColor + " = texture2D(" + Shader.UniAttribNameTexture0 + "," + Shader.FsAttribNameTexCoord + ");").append("\n");
                if (_hasColor) {
                    builder.append("    " + Shader.OutAttibNameColor + " = " + Shader.OutAttibNameColor + " * vec4( 1.0f, 1.0f, 1.0f, " + Shader.FsAttribNameColor + ".w);").append("\n");
                }
            }
            else if (_hasColor) {
                builder.append("    " + Shader.OutAttibNameColor + " = " + Shader.FsAttribNameColor + ";").append("\n");
            } else {
                builder.append("    " + Shader.OutAttibNameColor + " = vec4(1.0, 1.0, 1.0, 0.0);\n");
            }
        }
        
        builder.append("}\n");
    }
        
    private boolean     _hasColor       = false;
    private boolean     _hasTexCoord    = false;
    private boolean     _hasInstanced   = false;
    
    private int         _numInstances   = 0;
    private String[]    _vertexCustomCode               = null;
    private String[]    _fragmentCustomCode             = null;
}
