package de.orangestar.engine.render.shader;

/**
 * Provides a fluent shader builder to easily create and compile shader programs as needed.
 * 
 * @author Basti
 */
public class ShaderBuilder {
    
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    /*                              Public                                */
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    
    /**
     * Creates, compiles and returns the setup shader.
     */
    public Shader build() {
        
        StringBuilder strVertex = new StringBuilder();
        xs_head(strVertex);
        vs_in(strVertex);
        vs_out(strVertex);
        vs_main(strVertex);
        
        StringBuilder strFragment = new StringBuilder();
        xs_head(strFragment);
        fs_in(strFragment);
        fs_out(strFragment);
        fs_main(strFragment);
        
        Shader shader = new Shader(strVertex.toString() , strFragment.toString());

        shader._isColored   = _hasColor;
        shader._isTextured  = _hasTexCoord;
        shader._isInstanced = _hasInstanced;
        shader._numInstances= _numInstances;
        
        return shader;
    }

    /**
     * The shader shall support colored rendering.
     */
    public ShaderBuilder colored() {
        _hasColor = true;
        return this;
    }

    /**
     * The shader shall support textured rendering.
     */
    public ShaderBuilder textured() {
        _hasTexCoord = true;
        return this;
    }
    
    /**
     * The shader shall support instanced rendering with a maximum of <i>maxInstances</i> instances.
     */
    public ShaderBuilder instanced(int maxInstances) {
        _hasInstanced = true;
        _numInstances = maxInstances;
        return this;
    }
    
    /**
     * The shader shall use a custom vertexshader code.
     * For the shader variable/method naming conventions see {@link Shader}
     */
    public ShaderBuilder withCustomVertexShaderCode(String... srcs) {
        _vertexCustomCode = srcs;
        return this;
    }
    
    /**
     * The shader shall use a custom fragmentshader code.
     * For the shader variable/method naming conventions see {@link Shader}
     */
    public ShaderBuilder withCustomFragmentShaderCode(String... srcs) {
        _fragmentCustomCode = srcs;
        return this;
    }

    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    /*                              Private                               */
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    /**
     * Adds the cross-shader header for setting version, head comments, etc.
     */
    private void xs_head(StringBuilder builder) {
        builder.append("// Generated by ShaderBuilder rev01").append("\n");
        builder.append("#version 330").append("\n");

        builder.append("\n");
    }
    
    /**
     * Adds the IN section to the vertex shader code.
     */
    private void vs_in(StringBuilder builder) {   
        // Uniform
        builder.append("uniform mat4 ").append(Shader.UniAttribNameWVP).append(";");
        
        builder.append("\n").append("\n");
        
        // Layout
        builder.append("layout(location = ").append(Shader.VsAttribLocPosition).append(") in vec3 ").append(Shader.VsAttribNamePosition).append(";").append("\n");
        
        if (_hasColor) {
            builder.append("layout(location = ").append(Shader.VsAttribLocColor).append(") in vec4 ").append(Shader.VsAttribNameColor).append(";").append("\n");
        }
        
        if (_hasTexCoord) {
            builder.append("layout(location = ").append(Shader.VsAttribLocTexCoord).append(") in vec2 ").append(Shader.VsAttribNameTexCoord).append(";").append("\n");
        }
        
        if (_hasInstanced) {
            builder.append("layout(location = ").append(Shader.VsAttribLocInstances_Position_0).append(") in mat4 ").append(Shader.VsAttribNameInstances_Position).append(";").append("\n");
        }

        builder.append("\n");
    }
    
    /**
     * Adds the OUT section to the vertex shader code.
     */
    private void vs_out(StringBuilder builder) {
        if (_hasColor) {
            builder.append("out vec4 fs_color;").append("\n");
        }
        
        if (_hasTexCoord) {
            builder.append("out vec2 fs_texcoord;").append("\n");
        }
            
        builder.append("\n");
    }
    
    /**
     * Adds the MAIN method to the vertex shader code.
     */
    private void vs_main(StringBuilder builder) {        
        builder.append("void main() {").append("\n");
        
        
        if (_vertexCustomCode != null) {
            builder.append(_vertexCustomCode);
        } else {
            if (_hasInstanced) {
                builder.append("    ").append("gl_Position = (").append(Shader.VsAttribNameInstances_Position).append(" * vec4(vs_position, 1.0)) * uni_wvp;").append("\n");
            } else {
                builder.append("    ").append("gl_Position = vec4(vs_position, 1.0) * uni_wvp;").append("\n");
            }

            if (_hasColor) {
                builder.append("    ").append("fs_color = vs_color;").append("\n");
            }
            
            if (_hasTexCoord) {
                builder.append("    ").append("fs_texcoord = vs_texcoord;").append("\n");
            }
        }

        builder.append("}").append("\n");
    }
        
    /**
     * Adds the IN section to the fragment shader code.
     */
    private void fs_in(StringBuilder builder) {
        // Uniform
        if (_hasTexCoord) {
            builder.append("uniform sampler2D ").append(Shader.UniAttribNameTexture0).append(";").append("\n").append("\n");
        }
        
        // Layout
        if (_hasColor) {
            builder.append("in vec4 ").append(Shader.FsAttribNameColor).append(";").append("\n");
        }
        
        if (_hasTexCoord) {
            builder.append("in vec2 ").append(Shader.FsAttribNameTexCoord).append(";").append("\n");
        }
        
        builder.append("\n");
    }
    
    /**
     * Adds the OUT section to the vertex shader code.
     */
    private void fs_out(StringBuilder builder) {
        if (_hasColor || _hasTexCoord) {
            builder.append("out vec4 ").append(Shader.OutAttibNameColor).append(";").append("\n");
        }
        
        builder.append("\n");
    }
    
    /**
     * Adds the MAIN method to the fragment shader code.
     */
    private void fs_main(StringBuilder builder) {
        builder.append("void main() {").append("\n");

        if (_fragmentCustomCode != null) {
            builder.append(_fragmentCustomCode);
        } else {
            if (_hasTexCoord) {
                if (_hasColor) {
                    builder.append("    ").append(Shader.OutAttibNameColor).append(" = ").append(" texture2D(").append(Shader.UniAttribNameTexture0).append(",").append(Shader.FsAttribNameTexCoord).append(") * (").append(Shader.FsAttribNameColor).append(" + vec4(0.5,0.5,0.5,0));").append("\n");
                } else {
                    builder.append("    ").append(Shader.OutAttibNameColor).append(" = ").append(" texture2D(").append(Shader.UniAttribNameTexture0).append(",").append(Shader.FsAttribNameTexCoord).append(");").append("\n");
                }
            } else {
                if (_hasColor) {
                    builder.append("    ").append(Shader.OutAttibNameColor).append(" = ").append(Shader.FsAttribNameColor).append(";").append("\n");
                } else {
                    builder.append("");
                }
            }
        }
        
        builder.append("}").append("\n");
    }
    
    private boolean     _hasColor       = false;
    private boolean     _hasTexCoord    = false;
    private boolean     _hasInstanced   = false;
    
    private int         _numInstances   = 0;
    private String[]    _vertexCustomCode               = null;
    private String[]    _fragmentCustomCode             = null;
}
